
<!-- Generated on Thu 28 Jan 10:26:49 CET 2016.
     CHANGES TO THIS FILE WILL BE LOST. -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Jive reference manual: Array utility functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Jive reference manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Tutorials</span></a></li>
      <li><a href="modules.html"><span>Utilities</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Array utility functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of functions operating on arrays.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7d404bacdbfcfa6c85bfb22302b724b2"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga7d404bacdbfcfa6c85bfb22302b724b2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga7d404bacdbfcfa6c85bfb22302b724b2">jem::min</a> (const ArrayExpr&lt; T, N &gt; &amp;e)</td></tr>
<tr class="memdesc:ga7d404bacdbfcfa6c85bfb22302b724b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of an array expression.  <a href="#ga7d404bacdbfcfa6c85bfb22302b724b2">More...</a><br /></td></tr>
<tr class="separator:ga7d404bacdbfcfa6c85bfb22302b724b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d12ff4a6445bf3813f0360d1538224"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga83d12ff4a6445bf3813f0360d1538224"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga83d12ff4a6445bf3813f0360d1538224">jem::max</a> (const ArrayExpr&lt; T, N &gt; &amp;e)</td></tr>
<tr class="memdesc:ga83d12ff4a6445bf3813f0360d1538224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of an array expression.  <a href="#ga83d12ff4a6445bf3813f0360d1538224">More...</a><br /></td></tr>
<tr class="separator:ga83d12ff4a6445bf3813f0360d1538224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fe86c600be780ed57e9a2843e8d918"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga54fe86c600be780ed57e9a2843e8d918"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga54fe86c600be780ed57e9a2843e8d918">jem::sum</a> (const ArrayExpr&lt; T, N &gt; &amp;e)</td></tr>
<tr class="memdesc:ga54fe86c600be780ed57e9a2843e8d918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of all elements in an array expression.  <a href="#ga54fe86c600be780ed57e9a2843e8d918">More...</a><br /></td></tr>
<tr class="separator:ga54fe86c600be780ed57e9a2843e8d918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67188110bb1c96b2443783fc8e2c09bb"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga67188110bb1c96b2443783fc8e2c09bb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga67188110bb1c96b2443783fc8e2c09bb">jem::product</a> (const ArrayExpr&lt; T, N &gt; &amp;e)</td></tr>
<tr class="memdesc:ga67188110bb1c96b2443783fc8e2c09bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of all elements in an array expression.  <a href="#ga67188110bb1c96b2443783fc8e2c09bb">More...</a><br /></td></tr>
<tr class="separator:ga67188110bb1c96b2443783fc8e2c09bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac42ecaa12a73b40cb96eeda54c520023"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gac42ecaa12a73b40cb96eeda54c520023"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#gac42ecaa12a73b40cb96eeda54c520023">jem::testall</a> (const ArrayExpr&lt; T, N &gt; &amp;e)</td></tr>
<tr class="memdesc:gac42ecaa12a73b40cb96eeda54c520023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether all elements in an array expression are true.  <a href="#gac42ecaa12a73b40cb96eeda54c520023">More...</a><br /></td></tr>
<tr class="separator:gac42ecaa12a73b40cb96eeda54c520023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b3f41d4896b6c7f6ad34431c658db3f"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga0b3f41d4896b6c7f6ad34431c658db3f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga0b3f41d4896b6c7f6ad34431c658db3f">jem::testany</a> (const ArrayExpr&lt; T, N &gt; &amp;e)</td></tr>
<tr class="memdesc:ga0b3f41d4896b6c7f6ad34431c658db3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether at least one element in an array expression is true.  <a href="#ga0b3f41d4896b6c7f6ad34431c658db3f">More...</a><br /></td></tr>
<tr class="separator:ga0b3f41d4896b6c7f6ad34431c658db3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c2bab8503a141ca575596739880498"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa9c2bab8503a141ca575596739880498"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#gaa9c2bab8503a141ca575596739880498">jem::shift</a> (const ArrayExpr&lt; T, 1 &gt; &amp;e, int k)</td></tr>
<tr class="memdesc:gaa9c2bab8503a141ca575596739880498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts all elements in a one-dimensional array expresion.  <a href="#gaa9c2bab8503a141ca575596739880498">More...</a><br /></td></tr>
<tr class="separator:gaa9c2bab8503a141ca575596739880498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae440f88ea2d9d60a9638775ea85bfca8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae440f88ea2d9d60a9638775ea85bfca8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#gae440f88ea2d9d60a9638775ea85bfca8">jem::cshift</a> (const ArrayExpr&lt; T, 1 &gt; &amp;e, int k)</td></tr>
<tr class="memdesc:gae440f88ea2d9d60a9638775ea85bfca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts all elements in a one-dimensional array expression in a circular way.  <a href="#gae440f88ea2d9d60a9638775ea85bfca8">More...</a><br /></td></tr>
<tr class="separator:gae440f88ea2d9d60a9638775ea85bfca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b565026a458a347e59cd1991908a5a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac3b565026a458a347e59cd1991908a5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#gac3b565026a458a347e59cd1991908a5a">jem::reverse</a> (const ArrayExpr&lt; T, 1 &gt; &amp;e)</td></tr>
<tr class="memdesc:gac3b565026a458a347e59cd1991908a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the elements in a one-dimensional array expression.  <a href="#gac3b565026a458a347e59cd1991908a5a">More...</a><br /></td></tr>
<tr class="separator:gac3b565026a458a347e59cd1991908a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eacd10306e86720aecd9367f59dd342"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga4eacd10306e86720aecd9367f59dd342"><td class="memTemplItemLeft" align="right" valign="top">Array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga4eacd10306e86720aecd9367f59dd342">jem::reshape</a> (const Array&lt; T, 1 &gt; &amp;a, const Tuple&lt; int, N &gt; &amp;sh)</td></tr>
<tr class="memdesc:ga4eacd10306e86720aecd9367f59dd342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a one-dimensional array to a multi-dimcnsional array.  <a href="#ga4eacd10306e86720aecd9367f59dd342">More...</a><br /></td></tr>
<tr class="separator:ga4eacd10306e86720aecd9367f59dd342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f591a54107ceffcec569fe64dfcb46"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:ga38f591a54107ceffcec569fe64dfcb46"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga38f591a54107ceffcec569fe64dfcb46">jem::equal</a> (const ArrayExpr&lt; T, N &gt; &amp;lhs, const ArrayExpr&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga38f591a54107ceffcec569fe64dfcb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether two array expressions are equal.  <a href="#ga38f591a54107ceffcec569fe64dfcb46">More...</a><br /></td></tr>
<tr class="separator:ga38f591a54107ceffcec569fe64dfcb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae85b225b0c658231ec9cf1e9233046"><td class="memItemLeft" align="right" valign="top">ArrayExpr&lt; int, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga7ae85b225b0c658231ec9cf1e9233046">jem::iarray</a> (int n)</td></tr>
<tr class="memdesc:ga7ae85b225b0c658231ec9cf1e9233046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumeration of integers as an array expression.  <a href="#ga7ae85b225b0c658231ec9cf1e9233046">More...</a><br /></td></tr>
<tr class="separator:ga7ae85b225b0c658231ec9cf1e9233046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga171e1415bd54f167975ed77c23309900"><td class="memItemLeft" align="right" valign="top">ArrayExpr&lt; int, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga171e1415bd54f167975ed77c23309900">jem::iarray</a> (const SliceTo &amp;s)</td></tr>
<tr class="memdesc:ga171e1415bd54f167975ed77c23309900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumeration of integers as an array expression.  <a href="#ga171e1415bd54f167975ed77c23309900">More...</a><br /></td></tr>
<tr class="separator:ga171e1415bd54f167975ed77c23309900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a9d2986af812a5d18f50de093aec36"><td class="memItemLeft" align="right" valign="top">ArrayExpr&lt; int, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga51a9d2986af812a5d18f50de093aec36">jem::iarray</a> (const Slice &amp;s)</td></tr>
<tr class="memdesc:ga51a9d2986af812a5d18f50de093aec36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumeration of integers as an array expression.  <a href="#ga51a9d2986af812a5d18f50de093aec36">More...</a><br /></td></tr>
<tr class="separator:ga51a9d2986af812a5d18f50de093aec36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8717e09a5bb392faf0e008430fd29ae4"><td class="memItemLeft" align="right" valign="top">ArrayExpr&lt; int, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga8717e09a5bb392faf0e008430fd29ae4">jem::iarray</a> (const SliceFromTo &amp;s)</td></tr>
<tr class="memdesc:ga8717e09a5bb392faf0e008430fd29ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumeration of integers as an array expression.  <a href="#ga8717e09a5bb392faf0e008430fd29ae4">More...</a><br /></td></tr>
<tr class="separator:ga8717e09a5bb392faf0e008430fd29ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab295e0cc12deb1fcaecf1ffa2357cd24"><td class="memTemplParams" colspan="2">template&lt;class T , int N&gt; </td></tr>
<tr class="memitem:gab295e0cc12deb1fcaecf1ffa2357cd24"><td class="memTemplItemLeft" align="right" valign="top">Array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#gab295e0cc12deb1fcaecf1ffa2357cd24">jem::makeContiguous</a> (const Array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:gab295e0cc12deb1fcaecf1ffa2357cd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array to a contiguous array.  <a href="#gab295e0cc12deb1fcaecf1ffa2357cd24">More...</a><br /></td></tr>
<tr class="separator:gab295e0cc12deb1fcaecf1ffa2357cd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545a8b27e7161d00b4196eee74817605"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga545a8b27e7161d00b4196eee74817605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga545a8b27e7161d00b4196eee74817605">jem::sort</a> (const Array&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga545a8b27e7161d00b4196eee74817605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a one-dimensional array in ascending order.  <a href="#ga545a8b27e7161d00b4196eee74817605">More...</a><br /></td></tr>
<tr class="separator:ga545a8b27e7161d00b4196eee74817605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3df4a988efa0a24424155a0d6920613"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae3df4a988efa0a24424155a0d6920613"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#gae3df4a988efa0a24424155a0d6920613">jem::sort</a> (const Array&lt; int &gt; &amp;perm, const Array&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:gae3df4a988efa0a24424155a0d6920613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an array in ascending order through an index array.  <a href="#gae3df4a988efa0a24424155a0d6920613">More...</a><br /></td></tr>
<tr class="separator:gae3df4a988efa0a24424155a0d6920613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a8f78aa8ee2ca7e52b19251501e9a1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac0a8f78aa8ee2ca7e52b19251501e9a1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#gac0a8f78aa8ee2ca7e52b19251501e9a1">jem::binarySearch</a> (const T &amp;value, const Array&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:gac0a8f78aa8ee2ca7e52b19251501e9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sorted array for an element with a specific value.  <a href="#gac0a8f78aa8ee2ca7e52b19251501e9a1">More...</a><br /></td></tr>
<tr class="separator:gac0a8f78aa8ee2ca7e52b19251501e9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b980b8d8e86d2e9ae44093a26f0c26"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga62b980b8d8e86d2e9ae44093a26f0c26"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga62b980b8d8e86d2e9ae44093a26f0c26">jem::lowerBound</a> (const T &amp;value, const Array&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga62b980b8d8e86d2e9ae44093a26f0c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sorted array for the first element with a specific value.  <a href="#ga62b980b8d8e86d2e9ae44093a26f0c26">More...</a><br /></td></tr>
<tr class="separator:ga62b980b8d8e86d2e9ae44093a26f0c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga724c50fa66f49e1d261bbfbd3b836bb3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga724c50fa66f49e1d261bbfbd3b836bb3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga724c50fa66f49e1d261bbfbd3b836bb3">jem::upperBound</a> (const T &amp;value, const Array&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga724c50fa66f49e1d261bbfbd3b836bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sorted array for the first element that is larger than a specific value.  <a href="#ga724c50fa66f49e1d261bbfbd3b836bb3">More...</a><br /></td></tr>
<tr class="separator:ga724c50fa66f49e1d261bbfbd3b836bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bad12308f3dec93bd6c334641f88aad"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7bad12308f3dec93bd6c334641f88aad"><td class="memTemplItemLeft" align="right" valign="top">SliceFromTo&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ArrayUtilities.html#ga7bad12308f3dec93bd6c334641f88aad">jem::equalRange</a> (const T &amp;value, const Array&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga7bad12308f3dec93bd6c334641f88aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches a sorted array for a set of elements that all have a specific value.  <a href="#ga7bad12308f3dec93bd6c334641f88aad">More...</a><br /></td></tr>
<tr class="separator:ga7bad12308f3dec93bd6c334641f88aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><code>#include &lt;jem/base/array/utilities.h&gt;</code></p>
<p>This header file exports a collection of functions that perform various operations on <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> objects and array expressions. Supported operations are:</p>
<ul>
<li>reduce an array to a scalar; </li>
<li>shift the elements in an array; </li>
<li>test whether two arrays are equal; </li>
<li>sort an array and find a specific element.</li>
</ul>
<p>Note that these functions are also available through the general header file <code>&lt;jem/base/Array.h&gt;</code>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7d404bacdbfcfa6c85bfb22302b724b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T jem::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the minimum value of the array expression or <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object <em>e</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- an array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smallest element in the array. The return value is undefined if the array is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> supports the <code>&lt;</code> operator. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Array_8cpp-example.html#a14">Array.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga83d12ff4a6445bf3813f0360d1538224"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T jem::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the minimum value of the array expression or <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object <em>e</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- an array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The largest element in the array. The return value is undefined if the array is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> supports the <code>&lt;</code> operator. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Array_8cpp-example.html#a15">Array.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga54fe86c600be780ed57e9a2843e8d918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T jem::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the sum of all elements in the array expression or <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object <em>e</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- an array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all elements in the array. The return value is undefined if the array is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> supports the <code>+</code> operator. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Array_8cpp-example.html#a8">Array.cpp</a>, and <a class="el" href="Tuple_8cpp-example.html#a4">Tuple.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga67188110bb1c96b2443783fc8e2c09bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T jem::product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the product of all elements in the array expression or <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object <em>e</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- an array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product of all elements in the array. The return value is undefined if the array is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> supports the <code>*</code> operator. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="meshgen_8cpp-example.html#a17">meshgen.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac42ecaa12a73b40cb96eeda54c520023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool jem::testall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether all elements in the array expression or <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object <em>e</em> are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- an array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all elements in the array evaluate to <code>true</code>, and <code>false</code> otherwise. The return value is undefined if the array is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> can be converted to a boolean. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b3f41d4896b6c7f6ad34431c658db3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool jem::testany </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether at least one element in the array expression or <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object <em>e</em> is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- an array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if at least one elements in the array evaluates to <code>true</code>, and <code>false</code> otherwise. The return value is undefined if the array is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> can be converted to a boolean. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa9c2bab8503a141ca575596739880498"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void jem::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shifts all elements in the one-dimensional array expression <em>e</em> <em>k</em> places to the right. Thus, element <code>e</code>[i] becomes element <code>e[i + k]</code>. If <em>k</em> is negative, the elements are shifted to the left. The last <em>k</em> elements (or the first <em>k</em> elements if <em>k</em> is negative) are discarded, while the first <em>k</em> (or last <em>k</em>) elements are unchanged.</p>
<p>If <em>k</em> is larger than or equal to the size of the array expression <em>e</em>, then this functin does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- a one-dimensional, lvalue array expression.</td></tr>
    <tr><td class="paramname">k</td><td>- an integer specifying how many places the elements in <em>a</em> should be shifted to the right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> provides an assignment operator <br />
 and <em>e</em> is an lvalue expression. </dd></dl>

</div>
</div>
<a class="anchor" id="gae440f88ea2d9d60a9638775ea85bfca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void jem::cshift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function <code><a class="el" href="group__ArrayUtilities.html#gaa9c2bab8503a141ca575596739880498" title="Shifts all elements in a one-dimensional array expresion. ">shift()</a></code>, this function shifts all elements in the one-dimensional array expression <em>e</em> <em>k</em> places to the right. Thus, element <code>e</code>[i] becomes element <code>e[i + k]</code>. If <em>k</em> is negative, the elements are shifted to the left. Unlike <code><a class="el" href="group__ArrayUtilities.html#gaa9c2bab8503a141ca575596739880498" title="Shifts all elements in a one-dimensional array expresion. ">shift()</a></code>, however, the last <em>k</em> elements (or the first <em>k</em> elements if <em>k</em> is negative) are `wrapped around' and become the first (or last) <em>k</em> elements.</p>
<p>If <em>k</em> is larger than the size of the array <em>a</em>, then <em>k</em> is replaced by <code>(k % a.size())</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- a one-dimensional, lvalue array expression.</td></tr>
    <tr><td class="paramname">k</td><td>- an integer specifying the number of places that the elements in <em>a</em> should be shifted to the right.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the type <em>T</em> provides an assignment operator <br />
 and <em>e</em> is an lvalue expression. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3b565026a458a347e59cd1991908a5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void jem::reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverses the order in which the elements are stored in the one-dimensional array expression <em>e</em>. That is, the first element becomes the last element; the second element becomes the second last element; and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>- a one-dimensional, lvalue array expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the type <em>T</em> provides an assignment operator <br />
 and <em>e</em> is an lvalue expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4eacd10306e86720aecd9367f59dd342"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;T,N&gt; jem::reshape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Tuple.html">Tuple</a>&lt; int, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>sh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the one-dimensional array <em>a</em> to an <em>N</em>-dimensional array with shape <em>sh</em>. The returned array points to the same data block as the argument array <em>a</em>. Any modifications to the returned array are therefore visible in <em>a</em>, and the other way around.</p>
<p>Let <em>r</em> denote the array returned by this function. The mapping of the elements in <em>r</em> and the argument array <em>a</em> is defined as follows:</p>
<ul>
<li>if <em>N</em> equals two:<br />
 <code>r(i,j) == a[ i + j * sh[0] ]</code>;</li>
</ul>
<ul>
<li>if <em>N</em> equals three:<br />
 <code>r(i,j,k) == a[ i + j * sh[0] + k * sh[0] * sh[1] ]</code>;</li>
</ul>
<ul>
<li>if <em>N</em> equals four:<br />
 <code>r(i,j,k,p) == a [ i + j * sh[0] + k * sh[0] * sh[1] + p * sh[0] * sh[1] * sh[2] ]</code>.</li>
</ul>
<p>A different mapping can be obtained by invoking the member function <code><a class="el" href="classjem_1_1Array.html#a81b97dcf69a2c6a9279f7be980a1702d" title="Returns the transpose of this array. ">Array::transpose()</a></code> on the returned array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- a one-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code>.</td></tr>
    <tr><td class="paramname">sh</td><td>- the shape of the converted array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <em>N</em>-dimensional array pointing to the same data block as the argument array <em>a</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>product(sh) == a.size()</code> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Array_8cpp-example.html#a16">Array.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga38f591a54107ceffcec569fe64dfcb46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool jem::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1ArrayExpr.html">ArrayExpr</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether the shapes and the elements of the array expressions <em>lhs</em> and <em>rhs</em> are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>- an array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
    <tr><td class="paramname">rhs</td><td>- another array expression or an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code> equal( lhs.shape(), rhs.shape() ) &amp;&amp; <br />
 testall( lhs == rhs ) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ae85b225b0c658231ec9cf1e9233046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayExpr&lt;int,1&gt; jem::iarray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional array expression of length <em>n</em> that represents the integer array</p>
<p><code>[0, 1, 2, ..., n - 1]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- the length of the returned array expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n &gt;= 0</code></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A one-dimensional array expression enumerating all non-negative integers that are smaller than <em>n</em>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Array_8cpp-example.html#a9">Array.cpp</a>, and <a class="el" href="meshgen_8cpp-example.html#a18">meshgen.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga171e1415bd54f167975ed77c23309900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayExpr&lt;int,1&gt; jem::iarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1SliceTo.html">SliceTo</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional array expression that represents the integer array</p>
<p><code>[0, 1, 2, ..., s.last() - 1]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slice specifying the length of the returned array expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A one-dimensional array expression enumerating all integers selected by the slice object <em>s</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51a9d2986af812a5d18f50de093aec36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayExpr&lt;int,1&gt; jem::iarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Slice.html">Slice</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional array expression that represents the integer array</p>
<p><code>[i, i + k, i + 2 * k, ..., i + n * k]</code></p>
<p>with <code>i = s.first()</code> and <code>k = s.stride()</code>, and with <code>n</code> the largest integer such that</p>
<p><code>i + n * k &lt; s.last()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slice specifying the integers in the returned array expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A one-dimensional array expression enumerating all integers selected by the slice object <em>s</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8717e09a5bb392faf0e008430fd29ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ArrayExpr&lt;int,1&gt; jem::iarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1SliceFromTo.html">SliceFromTo</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one-dimensional array expression that represents the integer array</p>
<p><code>[i, i + 1, i + 2, ..., j - 1]</code></p>
<p>with <code>i = s.first()</code> and <code>j = s.last()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- a slice specifying the integers in the returned array expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A one-dimensional array expression enumerating all integers selected by the slice object <em>s</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab295e0cc12deb1fcaecf1ffa2357cd24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;T,N&gt; jem::makeContiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array that has the same shape as the array <em>a</em>; that has the same elements as <em>a</em>; and that is stored contiguously in memory. If the array <em>a</em> is already contiguous, then this function simply returns <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A contiguous array containing the same elements as <em>a</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classjem_1_1Array.html#a60b2ce9077060b1767909bd2f7b3cfb7" title="Tests whether this array is contiguous. ">Array::isContiguous()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga545a8b27e7161d00b4196eee74817605"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void jem::sort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements stored in the one-dimensional array <em>a</em> in such a way that</p>
<p><code>a[i + 1] &gt;= a[i]</code></p>
<p>for all valid indices <code>i</code>.</p>
<p>The worst-case time compexity of this function is <em>O(n*log(n))</em> with <em>n</em> the length of the array <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- a one-dimensional <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> that is to be sorted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> supports the assignment operator; and the type <em>T</em> supports the <code>&lt;</code> operator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current implementation is based on heap sort. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="TextInput_8cpp-example.html#a3">TextInput.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae3df4a988efa0a24424155a0d6920613"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void jem::sort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements in the index array <em>perm</em> in such a way that</p>
<p><code>a[ perm[i + 1] ] &gt;= a[ perm[i] ]</code></p>
<p>for all valid indices <code>i</code>.</p>
<p>The worst-case time compexity of this function is <em>O(n*log(n))</em> with <em>n</em> the length of the array <em>perm</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> of which the elements are valid indices into the array <em>a</em>.</td></tr>
    <tr><td class="paramname">a</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> provides a <code>&lt;</code> operator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current implementation is based on heap sort. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0a8f78aa8ee2ca7e52b19251501e9a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int jem::binarySearch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the element with value <em>value</em> in the sorted array <em>a</em>. If there is no such element, a negative integer is returned. If there are multiple elements with the value <em>value</em>, the index of any one of those elements is returned.</p>
<p>The worst-case time complexity of this function is <em>O(log(n))</em> with <em>n</em> the length of the array <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value of the element to be found.</td></tr>
    <tr><td class="paramname">a</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> that has been sorted in ascending order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the element with value <em>value</em>, or a negative integer if there is no element with that value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The array <em>a</em> has been sorted in ascending order; <br />
 and the type <em>T</em> provides the <code>&lt;</code> operator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__ArrayUtilities.html#ga545a8b27e7161d00b4196eee74817605" title="Sorts a one-dimensional array in ascending order. ">sort()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62b980b8d8e86d2e9ae44093a26f0c26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int jem::lowerBound </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the first element with value <em>value</em> in the sorted array <em>a</em>. If there is no such element, the returned index refers to the first element with a value larger than <em>value</em>. If <em>value</em> is larger than the largest element in the array, the size of the array is returned.</p>
<p>The worst-case time complexity of this function is <em>O(log(n))</em> with <em>n</em> the length of the array <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value of the element to be found.</td></tr>
    <tr><td class="paramname">a</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> that has been sorted in ascending order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first element with value <em>value</em>, or the index of the first element that is larger than <em>value</em>, or the size of the array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The array <em>a</em> has been sorted in ascending order; <br />
 and the type <em>T</em> provides the <code>&lt;</code> operator. </dd></dl>

</div>
</div>
<a class="anchor" id="ga724c50fa66f49e1d261bbfbd3b836bb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int jem::upperBound </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the first element with a value that is larger than <em>value</em> in the sorted array <em>a</em>. If there is no such element, the size of the array <em>a</em> is returned.</p>
<p>The worst-case time complexity of this function is <em>O(log(n))</em> with <em>n</em> the length of the array <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value of the element to be found.</td></tr>
    <tr><td class="paramname">a</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> that has been sorted in ascending order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first element that is larger than <em>value</em>, or the size of the array <em>a</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The array <em>a</em> has been sorted in ascending order; <br />
 and the type <em>T</em> provides the <code>&lt;</code> operator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__ArrayUtilities.html#ga545a8b27e7161d00b4196eee74817605" title="Sorts a one-dimensional array in ascending order. ">sort()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bad12308f3dec93bd6c334641f88aad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SliceFromTo jem::equalRange </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjem_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <code><a class="el" href="classjem_1_1SliceFromTo.html" title="A class for creating contiguous slices of array-like objects. ">SliceFromTo</a></code> object representing the indices of the elements that all have the value <em>value</em> in the sorted array <em>a</em>. If <em>s</em> denotes the returned slice object, then</p>
<p><code>a[i] == value</code></p>
<p>for all indices <em>i</em> that meet the condition</p>
<p><code>i &gt;= s.first() &amp;&amp; i &lt; s.last()</code></p>
<p>If there are no elements with the value <em>value</em>, then the returned slice object represents an empty range of indices.</p>
<p>The worst-case time complexity of this function is <em>O(log(n))</em> with <em>n</em> the length of the array <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value of the elements to be found.</td></tr>
    <tr><td class="paramname">a</td><td>- an <code><a class="el" href="classjem_1_1Array.html" title="Implements a multi-dimensional array that supports slicing and array expressions. ...">Array</a></code> that has been sorted in ascending order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classjem_1_1SliceFromTo.html" title="A class for creating contiguous slices of array-like objects. ">SliceFromTo</a></code> representing the indices of the elements with value <em>value</em>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The array <em>a</em> has been sorted in ascending order; <br />
 and the type <em>T</em> provides the <code>&lt;</code> operator.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__ArrayUtilities.html#ga545a8b27e7161d00b4196eee74817605" title="Sorts a one-dimensional array in ascending order. ">sort()</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->

<!-- Generated on Thu 28 Jan 10:26:49 CET 2016.
     CHANGES TO THIS FILE WILL BE LOST. -->
<hr class="footer"/>
<div class="footer">
  <a href="http://www.dynaflow.com">
    <img class="logo" align="left" src="logo.png"
      width="218" height="25" alt="logo" border="null"/>
  </a>
  <div align="right">
    <small>
      Generated on Thu Jan 28 2016 10:26:55 by Doxygen
    </small>
  </div>
</div>
</body>
</html>
